name: Log Hours - Deploy to VPS via DockerHub

on:
  push:
    branches: [ main ]
    paths: 
      - 'log_hours/**'
      - '.github/workflows/log-hours.yml'
  pull_request:
    branches: [ main ]
    paths: 
      - 'log_hours/**'
      - '.github/workflows/log-hours.yml'
  workflow_dispatch: # Allow manual trigger

env:
  DOCKER_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/work-logger
  CONTAINER_NAME: work-logger
  DEPLOY_PATH: /opt/work-logger
  WORKING_DIRECTORY: log_hours

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install Poetry
      uses: snok/install-poetry@v1
      with:
        version: latest
        virtualenvs-create: true
        virtualenvs-in-project: true

    - name: Load cached venv
      id: cached-poetry-dependencies
      uses: actions/cache@v3
      with:
        path: ${{ env.WORKING_DIRECTORY }}/.venv
        key: venv-${{ runner.os }}-${{ hashFiles('**/poetry.lock') }}

    - name: Install dependencies
      working-directory: ${{ env.WORKING_DIRECTORY }}
      run: |
        poetry install --no-interaction --no-ansi

    - name: Install Playwright browsers
      working-directory: ${{ env.WORKING_DIRECTORY }}
      run: |
        poetry run playwright install chromium
        poetry run playwright install-deps chromium

    - name: Run basic tests
      working-directory: ${{ env.WORKING_DIRECTORY }}
      run: |
        poetry run python -c "from loghours import TestLoghours; print('âœ… Import successful')"

  build-and-push:
    needs: test
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Login to DockerHub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.DOCKER_IMAGE }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: ./log_hours
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Test Docker image
      run: |
        echo "ðŸ§ª Testing Docker image..."
        docker run --rm ${{ env.DOCKER_IMAGE }}:latest python -c "from loghours import TestLoghours; print('âœ… Docker import test passed')"

  deploy:
    needs: [test, build-and-push]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup SSH key
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/id_ed25519
        chmod 600 ~/.ssh/id_ed25519
        ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts

    - name: Copy deployment files to VPS
      run: |
        # Copy docker-compose and deployment scripts from log_hours directory
        scp log_hours/docker-compose.yml ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}:/tmp/ || echo "No docker-compose.yml found"
        scp log_hours/docker-entrypoint.sh ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}:/tmp/ || echo "No docker-entrypoint.sh found"
        
        # Create and copy deployment script
        cat > deploy-script.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "ðŸš€ Starting DockerHub deployment to VPS (Log Hours)..."
        
        # Variables
        DEPLOY_PATH="${{ env.DEPLOY_PATH }}"
        CONTAINER_NAME="${{ env.CONTAINER_NAME }}"
        DOCKER_IMAGE="${{ env.DOCKER_IMAGE }}"
        
        # Create deployment directory
        sudo mkdir -p $DEPLOY_PATH
        sudo chown $USER:$USER $DEPLOY_PATH
        cd $DEPLOY_PATH
        
        # Copy docker files if they exist
        [ -f /tmp/docker-compose.yml ] && cp /tmp/docker-compose.yml .
        [ -f /tmp/docker-entrypoint.sh ] && cp /tmp/docker-entrypoint.sh . && chmod +x docker-entrypoint.sh
        
        # Create default docker-compose.yml if not exists
        if [ ! -f docker-compose.yml ]; then
          cat > docker-compose.yml << EOL
        version: '3.8'
        services:
          work-logger:
            image: \${DOCKER_IMAGE}
            container_name: \${CONTAINER_NAME}
            environment:
              - SYSTEM_USERNAME=\${SYSTEM_USERNAME}
              - SYSTEM_PASSWORD=\${SYSTEM_PASSWORD}
            volumes:
              - ./screenshots:/app/screenshots
              - ./logs:/app/logs
            restart: unless-stopped
        EOL
        fi
        
        # Create/update environment file
        echo "âš™ï¸ Setting up environment..."
        cat > .env << EOL
        DOCKER_IMAGE=$DOCKER_IMAGE:latest
        SYSTEM_USERNAME=${{ secrets.SYSTEM_USERNAME }}
        SYSTEM_PASSWORD=${{ secrets.SYSTEM_PASSWORD }}
        EOL
        
        # Set secure permissions
        chmod 600 .env
        
        # Create directories for volumes
        mkdir -p screenshots logs
        
        # Stop existing container
        echo "ðŸ›‘ Stopping existing container..."
        docker-compose down || true
        
        # Pull latest image from DockerHub
        echo "ðŸ“¥ Pulling latest image from DockerHub..."
        docker pull $DOCKER_IMAGE:latest
        
        # Clean up old images (keep last 2 versions)
        echo "ðŸ§¹ Cleaning up old images..."
        docker image prune -f || true
        
        # Start new container
        echo "ðŸš€ Starting new container..."
        docker-compose up -d
        
        # Wait for container to be ready
        echo "â³ Waiting for container to be ready..."
        sleep 10
        
        # Verify deployment
        echo "ðŸ” Verifying deployment..."
        if docker ps | grep -q $CONTAINER_NAME; then
          echo "âœ… Container is running"
          echo "ðŸ“‹ Container info:"
          docker ps | grep $CONTAINER_NAME
          echo "ðŸ“ Recent logs:"
          docker logs $CONTAINER_NAME --tail=20
        else
          echo "âŒ Container failed to start"
          echo "ðŸ“ Container logs:"
          docker logs $CONTAINER_NAME || true
          exit 1
        fi
        
        # Cleanup temp files
        rm -f /tmp/docker-compose.yml /tmp/docker-entrypoint.sh
        
        echo "âœ… Deployment completed successfully!"
        echo "ðŸ“ Container: $CONTAINER_NAME"
        echo "ðŸ³ Image: $DOCKER_IMAGE:latest"
        echo "ðŸ“‚ Location: $DEPLOY_PATH"
        
        EOF
        
        chmod +x deploy-script.sh
        scp deploy-script.sh ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}:/tmp/

    - name: Deploy to VPS
      run: |
        ssh ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} "bash /tmp/deploy-script.sh && rm /tmp/deploy-script.sh"

    - name: Verify deployment
      run: |
        ssh ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
        echo "ðŸ” Final verification..."
        
        cd ${{ env.DEPLOY_PATH }}
        
        # Check container status
        if docker ps | grep -q ${{ env.CONTAINER_NAME }}; then
          echo "âœ… Container is running"
          echo "ðŸ“Š Container stats:"
          docker stats ${{ env.CONTAINER_NAME }} --no-stream
        else
          echo "âŒ Container not running"
          exit 1
        fi
        
        # Test application
        echo "ðŸ§ª Testing application in container..."
        docker exec ${{ env.CONTAINER_NAME }} python -c "from loghours import TestLoghours; print('âœ… Application test passed')" || echo "âš ï¸ Application test skipped"
        
        # Show image info
        echo "ðŸ³ Current image info:"
        docker images | grep work-logger | head -5
        
        EOF

    - name: Send deployment notification
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "ðŸŽ‰ Log Hours DockerHub deployment to VPS completed successfully!"
          echo "ðŸ”— VPS: ${{ secrets.VPS_HOST }}"
          echo "ðŸ³ Image: ${{ env.DOCKER_IMAGE }}:latest"
          echo "ðŸ“¦ Container: ${{ env.CONTAINER_NAME }}"
          echo "ðŸ“‚ Path: ${{ env.DEPLOY_PATH }}"
          echo "ðŸŒ Registry: https://hub.docker.com/r/${{ secrets.DOCKERHUB_USERNAME }}/work-logger"
        else
          echo "âŒ Log Hours deployment failed!"
        fi 